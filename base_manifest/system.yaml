iac_sketch_infrastructure:
- description: The iac_sketch package code.
- infrastructure

iac_sketch_pitch:
- description: >
    Problem:
        Existing design solutions have limitations.
        1. Usually piecewise, scattered notes.
        2. Typically no source of truth, let alone a precise one.
        3. Limited means to assess the validity of a designed system.
        4. Limited archival functionality.

        IaC is a promising approach with a number of benefits.
        1. Precise source-of-truth for infrastructure.
        2. Can be used to deploy code.
        3. Works with version control.

        However, IaC has significant limitations too.
        1. Components are limited to those defined by the system. Cannot handle...
            - Human-completed tasks, e.g. negotiating service agreements
            - Planning components, e.g. requirements
            - Abstract components, e.g. un-implemented tasks
        2. Poorly handles WIP. Incomplete manifests yield errors.
        3. Different systems, different syntaxes. (Terraform partially solves this.)
        4. Not interpretable by laymen/not visual.

    Solution: A package for designing and documenting complicated systems from end to
    end. Users create a yaml manifest for the system they are planning to design, and
    add requirements, solutions, policies, etc. to the manifest as they are identified.

        Key features:
            1. Enables the construction of manifests with arbitrary components,
                including user-defined, incomplete, and pre-defined components.
                - working
            2. Analyzes manifests to evaluate the state of the infrastructure - working
                Which requirements do not yet have proposed solutions?
                Which requirements are not yet met?
                Which components are not defined or have invalid definitions?
                Which entities are not incorporated into the system?
                Are all to-dos and errors addressed?
            3. Compiles components into a relational database with well-defined
                relationships. - working
            4. Parses pre-existing Python (inc. docstrings) for components, avoiding
                duplicate definitions. - working
            5. Assists in the development of delivery plans. - in progress
            6. Generates documentation of the components. - in progress

iac_sketch_name:
- description: >
    The name the package goes by. Suggestions:
    - iac_sketch or iacs (pronounced "yaks")
    - IaCA or iaca (infrastructure as Code Architect)
    - manIaC
- satisfies: has_a_good_name

is_a_useful_tool:
- description: >
    Fundamentally, iac_sketch must serve a purpose.
- requirement: iac_sketch_infrastructure

records_system_architecture:
- requirement
- parent: is_a_useful_tool
- child: accepts_nested_entities_as_children

accepts_nested_entities_as_children:
- description: >
    The files are very hard to follow right now, in regards to parents and children.
    Allowing nesting as code works should be both straightforward and greatly improve
    readability.
- requirement:
    priority: 0.9

facilitates_system_design:
- requirement
- parent: is_a_useful_tool

implements_systems:
- requirement
- parent: is_a_useful_tool
- child: works_with_llms_to_implement_systems

works_with_llms_to_implement_systems:
- description: >
    Reflecting on this, this is low priority because it's already a very competitive
    space. Setting up an mcp server is probably a good idea, but calling agents is
    probably not helpful.
- requirement
- child: has_an_mcp_server
- child: directly_calls_agents

directly_calls_agents:
- description: Probably want to use langchain for this.
- requirement

enables_iterative_system_decomposition:
- description: >
    The requirements and components of complicated systems are rarely known all at
    once, but are assembled over time in an iterative process. This process includes
    gathering functional requirements from the stakeholders, identifying technical
    requirements/constraints, trial and error, and more. One of the goals of
    iac_sketch is to provide a constant, living source of truth that can be used for
    both the formalized design and also components and requirements not yet
    incorporated.
- requirement
- parent: facilitates_system_design

facilitates_a_source_of_truth:
- requirement
- parent: enables_iterative_system_decomposition

can_incorporate_poorly_formed_components:
- description: >
    While gathering information it is common to come across a piece of information that
    is clearly important, but poorly defined. We need to record such information so it
    can be defined and incorporated when more is known.
- requirement
- parent: enables_iterative_system_decomposition

test_can_incorporate_poorly_formed_components:
- description: We can test this by making a test manifest that's deliberately messy.
- test
- satisfies: can_incorporate_poorly_formed_components

validates_system_architecture:
- description: >
    iac_sketch must provide a series of automated tests that ensure the system
    architecture meets requirements.
- requirement
- parent: is_a_useful_tool

documents_system_architecture:
- description: >
    At any given time the code that defines the system must be able to be compiled and
    turned into a digestable, clear, format.
- requirement
- parent: is_a_useful_tool
- child: stores_manifest_data_in_a_useful_format

compliments_existing_agile_approaches:
- description: >
    There's no way iac_sketch can compete with the level of features provided by
    leading Agile software. We need to compliment them.
- requirement
- parent: is_a_useful_tool

stores_manifest_data_in_a_useful_format:
- description: The format we store the data in facilitates different applications.
- requirement

manifest_in_relational_db:
- description: >
    Relational databases are the default format for ECS systems. This is because
    each type of component is exactly equivalent to a table.
- satisfies: stores_manifest_data_in_a_useful_format
- benefit: >
    Optimized for working with all component instances of a given component type,
    aka "data-oriented design", one of the main original motivations for ECS.
    By storing the data in different tables for different component types, the data is
    fully prepared for bulk calculations and analysis involving those components.
- drawback: >
    Suboptimal for working with individual entitites.
    All the components for a given entity are scattered across different component
    tables.
- benefit: Familiar format for traditional data architects and engineers.
- drawback: >
    While relational databases are performance optimized, we're not working with large
    volumes of data here.

manifest_in_docstore_db:
- description: >
    Relational databases may be the default format for ECS systems, but
    document-oriented databases are the default format for manifests.
- satisfies: stores_manifest_data_in_a_useful_format
- benefit: >
    Optimized for working with individual entities. All the data for a given entity
    is stored in one location.
- drawback: >
    Suboptimal for working with all component instances of a given component type.
- benefit: Intuitive format for entity creation.

manifest_in_rdf:
- description: >
    Relational data format (RDF) is a way to store arbitrary data, and plays a big role
    in the development of the world wide web and the ongoing semantic web.
- benefit: Built to describe arbitrary data.
- drawback: >
    Support for RDF has fallen dramatically, with little work done beyond the 2000's.

compatible_with_a_config:
- description: Parameters for iac_sketch should be set in the provided manifest.
- requirement
- parent: is_a_useful_tool

has_good_syntax:
- parent: records_system_architecture
- requirement
- child: syntax_is_brief
- child: syntax_is_flexible

syntax_is_brief:
- requirement

syntax_is_flexible:
- description: Syntax can be used to describe nearly arbitrary data.
- requirement

uses_consistent_ecs_terminology:
- description: >
    Unfortunately, "system" and "component" are used in two different contexts
    currently--as part of system design (where components are pieces of a system)
    and as part of entity-component-system (where components are data).
- requirement
- parent: terminology_is_internally_consistent

draws_on_widely_used_system_design_terminology:
- description: E.g. the url(s) attached.
- requirement
- parent: terminology_is_externally_consistent
- url: https://github.com/donnemartin/system-design-primer

can_perform_registry_etl:
- description: iac_sketch must perform extract-transform-load operations on manifests to create registries.
- requirement

can_execute_tests:
- description: iac_sketch must run all validation tests to verify system requirements are met.
- requirement

can_document_workflows:
- description: iac_sketch must provide functionality to document system workflows and processes.
- requirement

minimizes_structure_repetition:
- description: >
    iac_sketch should not require the user to go through code and transcribe the
    structure into yaml when it's already defined.

    Possible solutions:
    1. Automatically retrieve structure from the code.
    2. Use the structure in the yaml to define code execution order
- requirement: iac_sketch_infrastructure

can_build_delivery_plan:
- description: >
    Given a set of prioritized requirements, can build a delivery plan.
- requirement: iac_sketch_infrastructure
- child: can_build_requirements_map
- child: can_calculate_the_most_efficient_paths
- child: can_budget_for_preference_and_fit

can_build_requirements_map:
- description: >
    A requirements map is a visual representation of requirements and the possible
    routes to complete them. Before deciding on any sort of algorithm, putting the data
    in a format for people to understand what needs to get done and how it relates
    comes first.
- requirement:
    priority: 0.9

can_calculate_the_most_efficient_paths:
- description: >
    Given a set of prioritized requirements, can suggest which to do in what order.
- requirement

can_budget_for_preference_and_fit:
- description: >
    The most efficient path isn't necessarily realistic: people have preferences and
    are better fits for some tasks than others.
- requirement

perform_registry_etl:
- description: >
    How entities are defined and parsed.
    When entities are defined, their definitions depend on existing entities.
    We want to create all entities in order, such that their dependencies
    are resolved first. This is the mathematical problem of topological
    sorting, and networkx can solve this problem.
- task
- satisfies: can_perform_registry_etl
- links:
    links: |
        extract_entities --> load_entities_to_registry
        load_entities_to_registry --> apply_preprocess_transforms
        apply_preprocess_transforms --> apply_system_transforms
        apply_system_transforms --> apply_postprocess_transforms

extract_entities:
- description: Load the entities.
- task
- parent: perform_registry_etl
- input:
    filename_patterns [list[str]]: Files matching these patterns are loaded.
    input_yaml [str]: Optional yaml-formatted input string.
- output:
    registry [registry]:
- child: extract_entities_from_yaml
- child: load_entities_to_registry

extract_entities_from_yaml:
- description: Read the entities from a yaml string or stream.
- task
- input:
    input_yaml [str]: 
    source [str]: Optional label of where the yaml came from.
- output:
    registry [registry]: 
- child: parse_components_list
- code: iac_sketch.etl.ExtractSystem.extract_entities_from_yaml

parse_components_list:
- description: Convert a dictionary containing components into a list of components.
- task
- input:
    entity [str]: Name of the entity associated with the components.
    comps [list]: The components themselves, as a dictionary.
    source [str]: Optional label of where the yaml came from.
- output:
    extracted_comps [list[dict]]: Parsed version of the components.
- code: iac_sketch.etl.ExtractSystem.parse_components_list

load_entities_to_registry:
- task
- input:
    entities [dataframe]:
- output:
    registry [registry]:

load_entities_to_registry:
- description: >
    An object containing all the components. At the core of the registry are the
    components, a dictionary containing one dataframe per component type,
    with one row per component instance.
- task
- input:
    entities [dataframe]: >
        DataFrame containing entities, with one row per component instance.
- output:
    registry [registry]: >
        An object containing all the components. At the core of the registry are the
        components, a dictionary containing one dataframe per component type,
        with one row per component instance.

apply_preprocess_transforms:
- description: >
    Applies a set of required transforms to components that must always occur
    before any other transforms.
- task
- links:
    links: |
        normalize_compinsts --> extract_compdefs
        extract_compdefs --> validate_compinsts
    link_type: depended_on_by

apply_system_transforms:
- description: >
    Applies a set of system-defined transforms.
- task

normalize_components:
- task
- input:
    registry [registry]: Registry containing component instances to format.
- output:
    registry [registry]: Registry containing formatted instances.

extract_compdefs:
- task
- input:
    registry [registry]: Registry containing unparsed component definitions.
- output:
    registry [registry]: Registry containing extracted component definitions.

validate_compinsts:
- task
- input:
    registry [registry]: Registry containing unconstrained compinsts.
- output:
    registry [registry]: Registry containing compinsts with compdefs applied.

apply_transforms:
- task
- links: |
    get_transform_order --> apply_transform

get_transform_order:
- task

apply_transform:
- task

codemia:
- description: A related product that advertises system design interview practice.
- url: codemia.io

figma:
- description: A related design and prototyping tool used for creating user interfaces.
- url: figma.com